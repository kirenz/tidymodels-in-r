---
title: "Tidymodels II: Resample Methods"
subtitle: "Learn how to build models with tidymodels"
author: "Prof. Dr. Jan Kirenz"
output:
 html_document:
  code_download: true 
  css: style.css 
  fig_height: 6
  fig_width: 8
  highlight: tango
  number_sections: yes
  theme: paper
  toc: yes
  toc_depth: 3
  toc_float: 
    collapsed: false
    smooth_scroll: true 
  df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = TRUE,
	message = FALSE,
	warning = FALSE
)
library(tidyverse)
library(tidymodels)
```

This tutorial is based on Alisson Hill's excellent tidymodels workshop. 

# Import data

```{r}
library(tidyverse)

ames <- read_csv("https://raw.githubusercontent.com/kirenz/datasets/master/ames.csv")

ames <- ames %>%
 select(-matches("Qu"))

```


# Build a model

## Model specification

Build the model and calculate rmse:

```{r}
library(tidymodels)

# model specification
lm_spec <- 
  linear_reg() %>% 
  set_engine("lm") %>% 
  set_mode(mode = "regression")

```

## Data split

```{r}
# data split
new_split <- initial_split(ames) 
new_train <- training(new_split) 
new_test <- testing(new_split)
```

## Fit the model

```{r}

# fit model 
lm_spec %>%
 fit(Sale_Price ~ Gr_Liv_Area , data = new_train) %>%
 predict(new_test) %>%
 mutate(truth = new_test$Sale_Price) %>%
 rmse(truth, .pred)

```


# Estimate multiple models

## RMSE with for loop

Repeat this process 10 times and store rmse values:

```{r}

rmses <- vector(length = 10, mode = "double") 

for (i in 1:10) {
  
  new_split <- initial_split(ames)
  new_train <- training(new_split)
  new_test <- testing(new_split)
  rmses[i] <-
    lm_spec %>%
    fit(Sale_Price ~ Gr_Liv_Area, data = new_train) %>%
    predict(new_test) %>%
    mutate(truth = new_test$Sale_Price) %>%
    rmse(truth, .pred) %>%
    pull(.estimate)
 
}

rmses
  
```

## Average RMSE

Convert values to dataframe:

```{r}
rmses %>% 
  tibble::enframe(name = "rmse")
```


Calculate mean:

```{r}
mean(rmses)
```

This process is relatively complicated. Instead of using a for loop, we can use use a simple function: `vfold_cv()`

# Cross-validation

## vfold_cv()

We perform a 10-fold cross-validation with the function `vfold_cv`:

```{r}
set.seed(100)

cv_folds <-
 vfold_cv(ames, 
          v = 10, 
          strata = Sale_Price,
          breaks = 4) 

cv_folds
```


## Fit the model

How to fit the model?

```{r}

split1 <- 
  cv_folds %>% 
  pluck("splits", 1) 

split1_train <- training(split1)
split1_test <- testing(split1)

lm_spec %>% 
  fit(Sale_Price ~ Gr_Liv_Area, data = split1_train) %>%
  predict(split1_test) %>%
  mutate(truth = split1_test$Sale_Price) %>%
  rmse(truth, .pred)

```

This has to be repeated with split2 to split10 ... this would be complicated.

## fit_resamples()

Trains and tests a resampled model. 

Option 1:

```{r}

fit_resamples(
 lm_spec,
 Sale_Price ~ Gr_Liv_Area,
 resamples = cv_folds
)

```

Option 2:

```{r}

lm_spec %>% 
  fit_resamples(
    Sale_Price ~ Gr_Liv_Area,
    resamples = cv_folds
    )

```

```{r}
lm_results <- 
  lm_spec %>% 
  fit_resamples(
    Sale_Price ~ Gr_Liv_Area,
    resamples = cv_folds
    )
```


## collect_metrics()

Unnest the metrics column from a tidymodels fit_resamples()

```{r}

lm_results %>% 
  collect_metrics(summarize = TRUE)

```

* `summarize = TRUE`is the default; averages across folds.

Calculation with `summarize = FALSE` gives us:

```{r}
lm_spec %>%
 fit_resamples(
 Sale_Price ~ Gr_Liv_Area,
 resamples = cv_folds
 ) %>%
 collect_metrics(summarize = FALSE)
```


```{r}
set.seed(100)

lm_spec %>%
  fit_resamples(Sale_Price ~ Gr_Liv_Area,
                resamples = cv_folds) %>%
   collect_metrics()

```

